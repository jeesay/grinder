// Mask Creation

const mask_io = [
  {
    name: 'fn_in',
    title: 'Input 3D map:',
    widget: 'file',
    option: '--i',
    filetype: 'NODE_MAP_CPIPE',
    default: '',
    placeholder: 'MRC map files (*.mrc)',
    help: `Provide an input MRC map from which to start binarizing the map.`,
  },
];

const mask_settings = [
  {
    name: 'lowpass_filter',
    title: 'Lowpass filter map (A)',
    widget: 'range',
    option: '--lowpass',
    default:  15, 
    range_min: 10, 
    range_max: 100, 
    range_step: 5,
    help: `Lowpass filter that will be applied to the input map, prior to binarization. To calculate solvent masks, a lowpass filter of 15-20A may work well.`,
  },
  {
    name: 'angpix',
    title: 'Pixel size (A)',
    widget: 'range',
    option: '--angpix',
    default:  -1, 
    range_min: 0.3, 
    range_max: 5, 
    range_step: 0.1,
    help: `Provide the pixel size of the input map in Angstroms to calculate the low-pass filter. This value is also used in the output image header.`,
  },
  {
    name: 'inimask_threshold',
    title: 'Initial binarisation threshold:',
    widget: 'range',
    option: '--ini_threshold',
    default:  0.02, 
    range_min: 0., 
    range_max: 0.5, 
    range_step: 0.01,
    help: `This threshold is used to make an initial binary mask from the average of the two unfiltered half-reconstructions. \
If you don't know what value to use, display one of the unfiltered half-maps in a 3D surface rendering viewer and find the lowest threshold that gives no noise peaks outside the reconstruction.`,
  },
  {
    name: 'extend_inimask',
    title: 'Extend binary map this many pixels:',
    widget: 'range',
    option: '--extend_inimask',
    default:  3, 
    range_min: 0, 
    range_max: 20, 
    range_step: 1,
    help: `The initial binary mask is extended this number of pixels in all directions.`
  },
  {
    name: 'width_mask_edge',
    title: 'Add a soft-edge of this many pixels:',
    widget: 'range',
    option: '--width_soft_edge',
    default:  3, 
    range_min: 0, 
    range_max: 20, 
    range_step: 1,
    help: `The extended binary mask is further extended with a raised-cosine soft edge of the specified width.`
  }
];


// Polishing
const polish_io = [
// I/O
  {
    name: 'fn_mic',
    title: 'Micrographs (from MotionCorr):',
    widget: 'file',
    option: '--corr_mic',
    filetype: 'NODE_MICS_CPIPE',
    placeholder: 'STAR files (*.star)',
    default: '.',
    help: `The input STAR file with the micrograph (and their movie metadata) from a MotionCorr job.`
  },
  {
    name: 'fn_data',
    title: 'Particles (from Refine3D or CtfRefine):',
    widget: 'file',
    option: '--i',
    filetype: 'NODE_PARTS_CPIPE',
    placeholder: 'STAR files (*.star)',
    help: `The input STAR file with the metadata of all particles.`
  },
  {
    name: 'fn_post',
    title: 'Postprocess STAR file:',
    widget: 'file',
    option: '--f',
    filetype: 'OUTNODE_POST',
    placeholder: 'STAR files (postprocess.star)',
    help: `The STAR file generated by a PostProcess job. \
The mask used for this postprocessing will be applied to the unfiltered half-maps and should encompass the entire complex. The resulting FSC curve will be used for weighting the different frequencies.`
  },
  {
    name: 'do_float16',
    title: 'Write output in float16?',
    option: '--float16',
    widget: 'bool',
    default: true ,
    help: `If set to Yes, this program will write output images in float16 MRC format. This will save a factor of two in disk space compared to the default of writing in float32. Note that RELION and CCPEM will read float16 images, but other programs may not (yet) do so. `
  },

// Frame range
  {
    name: 'first_frame',
    title: 'First movie frame:',
    option: '--first_frame',
    widget: 'range',
    default: 1., 
    range_min: 1., 
    range_max: 10., 
    range_step: 1,
    help: `First movie frame to take into account in motion fit and combination step  `
  },
  {
    name: 'last_frame',
    title: 'Last movie frame:',
    option: '--last_frame',
    widget: 'range',
    default: -1., 
    range_min: 5., 
    range_max: 50., 
    range_step: 1,
    help: `Last movie frame to take into account in motion fit and combination step. Values equal to or smaller than 0 mean 'use all frames'.  `
  },

  {
    name: 'extract_size',
    title: 'Extraction size (pix in unbinned movie):',
    widget: 'range',
    default: -1, 
    range_min: 64, 
    range_max: 1024, 
    range_step: 8,
    help: `Size of the extracted particles in the unbinned original movie(in pixels). This should be an even number.`
  },
  {
    name: 'rescale',
    title: 'Re-scaled size (pixels): ',
    widget: 'range',
    default: -1, 
    range_min: 64, 
    range_max: 1024, 
    range_step: 8,
    help: `The re-scaled value needs to be an even number.  `
  },
];


const polish_train = [
// Parameter optimisation
/*
  {
    name: 'do_param_optim',
    title: 'Train optimal parameters?"',
    widget: 'bool',
    default: false,
    help: `If set to Yes, then relion_motion_refine will estimate optimal parameter values for the three sigma values above on a subset of the data (determined by the minimum number of particles to be used below).`
  },
*/
  {
    name: 'eval_frac',
    title: 'Fraction of Fourier pixels for testing: ',
    option: '--eval_frac',
    widget: 'range',
    default: 0.5, 
    range_min: 0, 
    range_max: 1., 
    range_step: 0.01,
    help: `This fraction of Fourier pixels (at higher resolution) will be used for evaluation of the parameters (test set), whereas the rest (at lower resolution) will be used for parameter estimation itself (work set).  `
  },
  {
    name: 'optim_min_part',
    title: 'Use this many particles: ',
    option: '--min_p',
    widget: 'range',
    default: 10000, 
    range_min: 5000, 
    range_max: 50000, 
    range_step: 1000,
    help: `Use at least this many particles for the meta-parameter optimisation. The more particles the more expensive in time and computer memory the calculation becomes, but the better the results may get.  `
  },
];

const polish_ptcls_optim = [
// motion_fit
/*
  {
    name: 'do_polish',
    title: 'Perform particle polishing?',
    widget: 'bool',
    default: true,
    help: `If set to Yes, then relion_motion_refine will be run to estimate per-particle motion-tracks using the parameters below, and polished particles will be generated.`
  },
*/
  {
    name: 'opt_params',
    title: 'Optimised parameter file:',
    option: '--params_file',
    widget: 'file',
    filetype: 'OUTNODE_POLISH_PARAMS',
    placeholder: 'TXT files (*.txt)',
    help: `The output TXT file from a previous Bayesian polishing job in which the optimal parameters were determined.  `
  },
];

const polish_ptcls = [
  {
    name: 'sigma_vel',
    title: 'Sigma for velocity (A/dose): ',
    widget: 'range',
    default: 0.2, 
    range_min: 1., 
    range_max: 10., 
    range_step: 0.1,
    help: `Standard deviation for the velocity regularisation. Smaller values requires the tracks to be shorter.`
  },
  {
    name: 'sigma_div',
    title: 'Sigma for divergence (A): ',
    widget: 'range',
    default: 5000, 
    range_min: 0, 
    range_max: 10000, 
    range_step: 10000,
    help: `Standard deviation for the divergence of tracks across the micrograph. Smaller values requires the tracks to be spatially more uniform in a micrograph.  `
  },
  {
    name: 'sigma_acc',
    title: 'Sigma for acceleration (A/dose): ',
    widget: 'range',
    default: 2, 
    range_min: -1, 
    range_max: 7, 
    range_step: 0.1,
    help: `Standard deviation for the acceleration regularisation. Smaller values requires the tracks to be straighter.  `
  },

//combine_frames
  {
    name: 'minres',
    title: 'Minimum resolution for B-factor fit (A): ',
    widget: 'range',
    default: 20, 
    range_min: 8, 
    range_max: 40, 
    range_step: 1,
    help: `The minimum spatial frequency (in Angstrom) used in the B-factor fit.  `
  },
  {
    name: 'maxres',
    title: 'Maximum resolution for B-factor fit (A): ',
    widget: 'range',
    default: -1, 
    range_min: -1, 
    range_max: 15, 
    range_step: 1,
    help: `The maximum spatial frequency (in Angstrom) used in the B-factor fit. If a negative value is given, the maximum is determined from the input FSC curve.  `
  },
];


// Sharpening
const sharpen_io = [
/*
HACK: TOMO
  {
    name: 'in_optimisation',
    title: 'Input optimisation set:', 
    widget: 'file',
    filetype: 'OUTNODE_TOMO_OPTIMISATION',
    placeholder: 'Optimisation set STAR file (*.star)',
    help:`Input tomo optimisation set. Half map files will be extracted. If half maps are specified below, then they will override the components in this optimisation set.`
  },
*/
  {
    name: 'fn_in',
    title: 'One of the 2 unfiltered half-maps:',
    option: '--i',
    widget: 'file',
    filetype: 'NODE_HALFMAP_CPIPE',
    placeholder: 'MRC map files (*half1*.mrc)', 
    help: `Provide one of the two unfiltered half-reconstructions that were output upon convergence of a 3D auto-refine run.`
  },
  {
    name: 'fn_mask',
    title: 'Solvent mask:',
    option: '--mask',
    widget: 'file',
    filetype: 'NODE_MASK_CPIPE',
    placeholder: 'Image Files (*.{spi,vol,msk,mrc})',
    help:`Provide a soft mask where the protein is white (1) and the solvent is black (0). Often, the softer the mask the higher resolution estimates you will get. A soft edge of 5-10 pixels is often a good edge width.`
  },
];

const sharpen_auto = [
  {
    name: 'sh_auto',
    title: 'Sharpening - Automatic B-factor estimation',
    widget: 'fieldset',
    children: [
      {
        name: 'angpix',
        title: 'Calibrated pixel size (A)',
        option: '--angpix',
        widget: 'range',
        default: -1, 
        range_min: 0.3, 
        range_max: 5, 
        range_step: 0.01,
        help: `Provide the final, calibrated pixel size in Angstroms. This value may be different from the pixel-size used thus far, e.g. when you have recalibrated the pixel size using the fit to a PDB model. The X-axis of the output FSC plot will use this calibrated value.`
      },
      {
        name: 'autob_lowres',
        title: 'Lowest resolution for auto-B fit (A):',
        option: '--autob_lowres',
        widget: 'range',
        default: 10, 
        range_min: 8, 
        range_max: 15, 
        range_step: 0.5,
        help: `This is the lowest frequency (in Angstroms) that will be included in the linear fit of the Guinier plot as described in Rosenthal and Henderson (2003, JMB). Dont use values much lower or higher than 10 Angstroms. If your map does not extend beyond 10 Angstroms, then instead of the automated procedure use your own B-factor.`
      },
      {
        name: 'fn_mtf',
        title: 'MTF of the detector (STAR file)',
        option: '--mtf',
        widget: 'file',
        placeholder:'STAR Files (*.star)',
        help:`If you know the MTF of your detector, provide it here. Curves for some well-known detectors may be downloaded from the RELION Wiki. Also see there for the exact format \
    \n If you do not know the MTF of your detector and do not want to measure it, then by leaving this entry empty, you include the MTF of your detector in your overall estimated B-factor upon sharpening the map.\
    Although that is probably slightly less accurate, the overall quality of your map will probably not suffer very much.`
      },
      {
        name: 'mtf_angpix',
        title: 'Original detector pixel size:',
        option: '--mtf_angpix',
        widget: 'range',
        default: 1.0, 
        range_min: 0.3, 
        range_max: 2.0, 
        range_step: 0.01,
        help: `This is the original pixel size (in Angstroms) in the raw (non-super-resolution!) micrographs.`
      },
      {
        name: 'fsc_weighting',
        title: 'Skip FSC-weighting',
        widget: 'fieldset',
        children: [
          {
            name: 'do_skip_fsc_weighting',
            title: 'Skip FSC-weighting',
            widget: 'switch',
            default: false,
            help: `If set to No (the default), then the output map will be low-pass filtered according to the mask-corrected, gold-standard FSC-curve. \
        Sometimes, it is also useful to provide an ad-hoc low-pass filter (option below), as due to local resolution variations some parts of the map may be better and other parts may be worse than the overall resolution as measured by the FSC. \
        In such cases, set this option to Yes and provide an ad-hoc filter as described below.`
          },
          {
            name: 'low_pass',
            title: 'Ad-hoc low-pass filter (A):',
            widget: 'range',
            default: 5,
            range_min: 1,
            range_max: 40,
            range_step: 1,
            help: `This option allows one to low-pass filter the map at a user-provided frequency (in Angstroms). When using a resolution that is higher than the gold-standard FSC-reported resolution, take care not to interpret noise in the map for signal...`
          },
        ]
      },
    ]
  }
]

const sharpen_manual = [
  {
    name: 'angpix',
    title: 'Calibrated pixel size (A)',
    option: '--angpix',
    widget: 'range',
    default: -1, 
    range_min: 0.3, 
    range_max: 5, 
    range_step: 0.01,
    help: `Provide the final, calibrated pixel size in Angstroms. This value may be different from the pixel-size used thus far, e.g. when you have recalibrated the pixel size using the fit to a PDB model. The X-axis of the output FSC plot will use this calibrated value.`
  },
  {
    name: 'adhoc_bfac',
    title: 'User-provided B-factor:', 
    widget: 'range',
    default: -1000, 
    range_min: -2000, 
    range_max: 0, 
    range_step: -50,
    help: `Use negative values for sharpening. Be careful: if you over-sharpen your map, you may end up interpreting noise for signal!`
  },
  {
    name: 'fn_mtf',
    title: 'MTF of the detector (STAR file)',
    option: '--mtf',
    widget: 'file',
    placeholder:'STAR Files (*.star)',
    help:`If you know the MTF of your detector, provide it here. Curves for some well-known detectors may be downloaded from the RELION Wiki. Also see there for the exact format \
\n If you do not know the MTF of your detector and do not want to measure it, then by leaving this entry empty, you include the MTF of your detector in your overall estimated B-factor upon sharpening the map.\
Although that is probably slightly less accurate, the overall quality of your map will probably not suffer very much.`
  },
  {
    name: 'mtf_angpix',
    title: 'Original detector pixel size:',
    option: '--mtf_angpix',
    widget: 'range',
    default: 1.0, 
    range_min: 0.3, 
    range_max: 2.0, 
    range_step: 0.01,
    help: `This is the original pixel size (in Angstroms) in the raw (non-super-resolution!) micrographs.`
  },
  {
    name: 'do_skip_fsc_weighting',
    title: 'Skip FSC-weighting',
    widget: 'switch',
    default: false,
    help: `If set to No (the default), then the output map will be low-pass filtered according to the mask-corrected, gold-standard FSC-curve. \
Sometimes, it is also useful to provide an ad-hoc low-pass filter (option below), as due to local resolution variations some parts of the map may be better and other parts may be worse than the overall resolution as measured by the FSC. \
In such cases, set this option to Yes and provide an ad-hoc filter as described below.`
  },
  {
    name: 'low_pass',
    title: 'Ad-hoc low-pass filter (A):',
    widget: 'range',
    default: 5,
    range_min: 1,
    range_max: 40,
    range_step: 1,
    help: `This option allows one to low-pass filter the map at a user-provided frequency (in Angstroms). When using a resolution that is higher than the gold-standard FSC-reported resolution, take care not to interpret noise in the map for signal...`
  },
]

// Mask Creation

const mask_io_tab = {
  widget: 'navtab',
  children: mask_io
}

const mask_settings_tab = {
  widget: 'navtab',
  children: mask_settings
}

// Sharpening
const post_io_settings = {
  widget: 'navtab',
  children: sharpen_io
}

const post_settings = (flag) => ({
  widget: 'navtab',
  children: (flag) ? sharpen_auto : sharpen_manual
})


// CTF refinement 

const ctfrefine_aniso_tab = {
  widget: 'navtab',
  children: [ctfrefine_aniso, ctfrefine_minres]
}

const ctfrefine_aberrations_tab = {
  widget: 'navtab',
  children: [ctfrefine_aberrations, ctfrefine_minres]
}

const ctfrefine_defocus_tab = {
  widget: 'navtab',
  children: [...ctfrefine_defocus, ctfrefine_minres]
}

const ctfrefine_fit_tab = {
  widget: 'navtab',
  children: [
    ctfrefine_aniso,
    {
      name: 'ctffit_field',
      title: 'CTF Parameter fitting',
      widget: 'fieldset',
      children: [
        {
          name: 'do_ctf',
          title: 'Perform CTF parameter fitting?',
          widget: 'switch',
          default: false, 
          help: `If set to Yes, then relion_ctf_refine will be used to estimate the selected parameters below.`,
        },
        ...ctfrefine_defocus,
      ]
    }, 
    ctfrefine_aberrations,
    ctfrefine_minres
  ]
}


// Polishing 

const polish_io_tab = {
  widget: 'navtab',
  children: polish_io
}

const polish_train_settings = {
  widget: 'navtab',
  children: polish_train
}

const polish_ptcls_optim_settings = {
  widget: 'navtab',
  children: polish_ptcls_optim
}

const polish_ptcls_settings = {
  widget: 'navtab',
  children: polish_ptcls
}


// Tabs
const postprocess_tabs = [
  {
    name: 'do_postprocess',
    title: 'Tools',
    icon: 'bi-wrench-adjustable',
    widget: 'navtab',
    children: [
      {
        name: 'polish',
        title: 'Mask creation',
        icon: 'bi-1-circle-fill',
        widget: 'fieldset',
        children: [
          {
            name: 'mask',
            title: 'Mask Creation',
            option: '',
            widget: 'radio',
            group: 'postprocess',
            help: '',
            on_click: (ev) => w_navtab_update({io: mask_io_tab, settings: mask_settings_tab})
          },
        ]
      },
      {
        name: 'polish',
        title: 'Post-processing',
        icon: 'bi-2-circle-fill',
        widget: 'fieldset',
        children: [
          {
            name: 'sharpen',
            title: 'Sharpening with automatic estimation of B-factor',
            option: '--auto_bfac',
            widget: 'radio',
            group: 'postprocess',
            help: 'If set to Yes, then the program will use the automated procedure described by Rosenthal and Henderson (2003, JMB) to estimate an overall B-factor for your map, and sharpen it accordingly. \
Note that your map must extend well beyond the lowest resolution included in the procedure below, which should not be set to resolutions much lower than 10 Angstroms. ',
            on_click: (ev) => w_navtab_update({io: post_io_settings, settings: post_settings(true)})
          },
          {
            name: 'sharpen',
            title: 'Sharpening with user-provided B-factor',
            option: '--adhoc_bfac',
            widget: 'radio',
            group: 'postprocess',
            help: 'Instead of using the automated B-factor estimation, provide your own value. Use negative values for sharpening the map. \
This option is useful if your map does not extend beyond the 10A needed for the automated procedure, or when the automated procedure does not give a suitable value (e.g. in more disordered parts of the map).',
            on_click: (ev) => w_navtab_update({io: post_io_settings, settings: post_settings(false)})
          },
        ]
      },
      {
        name: 'ctfrefine',
        title: 'CTF Refinement',
        icon: 'bi-3-circle-fill',
        widget: 'fieldset',
        children: [
         {
            name: 'ctfrefine_ab',
            title: 'Estimate higher-order aberrations',
            job: 'relion.ctfrefine',
            widget: 'radio',
            option: '--use_gctf',
            group: 'toolkit',
            help: ``,
            on_click: (ev) => w_navtab_update({io: ctfrefine_io,settings: ctfrefine_aberrations_tab})
          },
         {
            name: 'ctfrefine_an',
            title: 'Estimate anisotropic magnification',
            job: 'relion.ctfrefine',
            widget: 'radio',
            option: '--use_gctf',
            group: 'toolkit',
            help: ``,
            on_click: (ev) => w_navtab_update({io: ctfrefine_io, settings: ctfrefine_aniso_tab})
          },
         {
            name: 'ctfrefine_df',
            title: 'Estimate per-particle defocus values',
            job: 'relion.ctfrefine',
            widget: 'radio',
            option: '--use_gctf',
            group: 'toolkit',
            help: ``,
            on_click: (ev) => w_navtab_update({io: ctfrefine_io,settings: ctfrefine_defocus_tab})
          },
         {
            name: 'ctfrefine_ad',
            title: 'Advanced CTF refinement (relion menu)',
            job: 'relion.ctfrefine',
            widget: 'radio',
            option: '--use_gctf',
            group: 'toolkit',
            help: ``,
            on_click: (ev) => w_navtab_update({io: ctfrefine_io,settings: ctfrefine_fit_tab})
          },
        ]
      },
      {
        name: 'polish',
        title: 'Bayesian polishing',
        icon: 'bi-4-circle-fill',
        widget: 'fieldset',
        children: [
          {
            name: 'polish_train',
            title: 'Train optimal parameters',
            widget: 'radio',
            option: '',
            group: 'postprocess',
            help: `If set to Yes, then 'relion_motion_refine' will estimate optimal parameter values for the three sigma values above on a subset of the data (determined by the minimum number of particles to be used below).`,
            on_click: (ev) => w_navtab_update({io: polish_io_tab, settings: polish_train_settings})
          },
          {
            name: 'polish_anisomag',
            title: 'Perform particle polishing with optimised parameters (above)',
            widget: 'radio',
            option: '',
            group: 'postprocess',
            help: `If set to Yes, then 'relion_motion_refine' will be run to estimate per-particle motion-tracks using the parameters below, and polished particles will be generated.`,
            on_click: (ev) => w_navtab_update({io: polish_io_tab, settings: polish_ptcls_optim_settings})
          },
          {
            name: 'polish_manual',
            title: 'Perform particle polishing manually',
            widget: 'radio',
            option: '',
            group: 'postprocess',
            help: `If set to Yes, you specify yourself the parameters`,
            on_click: (ev) => w_navtab_update({io: polish_io_tab, settings: polish_ptcls_settings})
          },
        ]
      },
    ]
  },
  {
    name: 'io',
    icon: 'bi-arrow-down-up',
    title: 'I/O',
    widget: 'navtab',
    children: []
  },
  {
    name: 'settings',
    icon: 'bi-tools',
    title: 'Settings',
    widget: 'navtab',
    children: []
  },
  {
    name: 'running',
    icon: 'bi-send',
    title: 'Running',
    widget: 'navtab',
    children: [
      {
        widget: 'fieldset',
        title: 'Processes and Threads',
        children: [
          mpi_settings,
          thread_settings,
        ]
      },
      queue_settings,
      ...submit_settings
    ]
  }
];

