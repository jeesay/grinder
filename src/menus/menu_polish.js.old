const polish = [
  // I/O
  {
    name: 'fn_mic',
    title: 'Micrographs (from MotionCorr):',
    widget: 'file',
    filetype: 'NODE_MICS_CPIPE',
    placeholder: 'STAR files (*.star)',
    help: `The input STAR file with the micrograph (and their movie metadata) from a MotionCorr job.`
  },
  {
    name: 'fn_data',
    title: 'Particles (from Refine3D or CtfRefine):',
    widget: 'file',
    filetype: 'NODE_PARTS_CPIPE',
    placeholder: 'STAR files (*.star)',
    help: `The input STAR file with the metadata of all particles.`
  },
  {
    name: 'fn_post',
    title: 'Postprocess STAR file:',
    widget: 'file',
    filetype: 'OUTNODE_POST,  "',
    placeholder: 'STAR files (postprocess.star)',
    help: `The STAR file generated by a PostProcess job. \
The mask used for this postprocessing will be applied to the unfiltered half-maps and should encompass the entire complex. The resulting FSC curve will be used for weighting the different frequencies.`
  },
  {
    name: 'do_float16',
    title: 'Write output in float16?',
    widget: 'bool',
    default: true ,
    help: `If set to Yes, this program will write output images in float16 MRC format. This will save a factor of two in disk space compared to the default of writing in float32. Note that RELION and CCPEM will read float16 images, but other programs may not (yet) do so.`
  },

  // Frame range
  {
    name: 'first_frame',
    title: 'First movie frame: ',
    widget: 'range',
    default: 1., 
    range_min: 1., 
    range_max: 10., 
    range_step: 1, 
    help: `First movie frame to take into account in motion fit and combination step`
  },
  {
    name: 'last_frame',
    title: 'Last movie frame: ',
    widget: 'range',
    default: -1., 
    range_min: 5., 
    range_max: 50., 
    range_step: 1, 
    help: `Last movie frame to take into account in motion fit and combination step. Values equal to or smaller than 0 mean 'use all frames'.`
  },

  {
    name: 'extract_size',
    title: 'Extraction size (pix in unbinned movie):',
    widget: 'range',
    default: -1, 
    range_min: 64, 
    range_max: 1024, 
    range_step: 8, 
    help: `Size of the extracted particles in the unbinned original movie(in pixels). This should be an even number.`
  },
  {
    name: 'rescale',
    title: 'Re-scaled size (pixels): ',
    widget: 'range',
    default: -1, 
    range_min: 64, 
    range_max: 1024, 
    range_step: 8, 
    help: `The re-scaled value needs to be an even number.`
  },

  // Parameter optimisation
  {
    name: 'do_param_optim',
    title: 'Train optimal parameters?',
    widget: 'bool',
    default: false, 
    help: `If set to Yes, then relion_motion_refine will estimate optimal parameter values for the three sigma values above on a subset of the data (determined by the minimum number of particles to be used below).`
  },
  {
    name: 'eval_frac',
    title: 'Fraction of Fourier pixels for testing: ',
    widget: 'range',
    default: 0.5, 
    range_min: 0, 
    range_max: 1., 
    range_step: 0.01, 
    help: `This fraction of Fourier pixels (at higher resolution) will be used for evaluation of the parameters (test set), whereas the rest (at lower resolution) will be used for parameter estimation itself (work set).`
  },
  {
    name: 'optim_min_part',
    title: 'Use this many particles: ',
    widget: 'range',
    default: 10000, 
    range_min: 5000, 
    range_max: 50000, 
    range_step: 1000, 
    help: `Use at least this many particles for the meta-parameter optimisation. The more particles the more expensive in time and computer memory the calculation becomes, but the better the results may get.`
  },

  // motion_fit
  {
    name: 'do_polish',
    title: 'Perform particle polishing?',
    widget: 'bool',
    default: true, 
    help: `If set to Yes, then relion_motion_refine will be run to estimate per-particle motion-tracks using the parameters below, and polished particles will be generated.`
  },
  {
    name: 'opt_params',
    title: 'Optimised parameter file:',
    filetype: 'OUTNODE_POLISH_PARAMS',
    placeholder: 'TXT files (*.txt)',
    help: `The output TXT file from a previous Bayesian polishing job in which the optimal parameters were determined.`
  },
  {
    name: 'do_own_params',
    title: 'OR use your own parameters?',
    default: false, 
    help: `If set to Yes, then the field for the optimised parameter file will be ignored and the parameters specified below will be used instead.`
  },
  {
    name: 'sigma_vel',
    title: 'Sigma for velocity (A/dose): ',
    widget: 'range',
    default: 0.2, 
    range_min: 1., 
    range_max: 10., 
    range_step: 0.1, 
    help: `Standard deviation for the velocity regularisation. Smaller values requires the tracks to be shorter.`
  },
  {
    name: 'sigma_div',
    title: 'Sigma for divergence (A): ',
    widget: 'range',
    default: 5000, 
    range_min: 0, 
    range_max: 10000, 
    range_step: 1000, 
    help: `Standard deviation for the divergence of tracks across the micrograph. Smaller values requires the tracks to be spatially more uniform in a micrograph.`
  },
  {
    name: 'sigma_acc',
    title: 'Sigma for acceleration (A/dose): ',
    widget: 'range',
    default: 2, 
    range_min: -1, 
    range_max: 7, 
    range_step: 0.1, 
    help: `Standard deviation for the acceleration regularisation. Smaller values requires the tracks to be straighter.`
  },

//combine_frames
  {
    name: 'minres',
    title: 'Minimum resolution for B-factor fit (A): ',
    widget: 'range',
    default: 20, 
    range_min: 8, 
    range_max: 40, 
    range_step: 1, 
    help: `The minimum spatial frequency (in Angstrom) used in the B-factor fit.`
  },
  {
    name: 'maxres',
    title: 'Maximum resolution for B-factor fit (A): ',
    widget: 'range',
    default: -1, 
    range_min: -1, 
    range_max: 15, 
    range_step: 1, 
    help: `The maximum spatial frequency (in Angstrom) used in the B-factor fit. If a negative value is given, the maximum is determined from the input FSC curve.`
  },
]
